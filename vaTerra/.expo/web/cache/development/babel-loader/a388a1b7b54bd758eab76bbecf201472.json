{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _extends from \"@babel/runtime/helpers/extends\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nimport React, { Component } from \"react\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport PanResponder from \"react-native-web/dist/exports/PanResponder\";\nimport { vh, vw } from 'react-native-css-vh-vw';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport var SliderPickerCursor = function (_Component) {\n  _inherits(SliderPickerCursor, _Component);\n\n  var _super = _createSuper(SliderPickerCursor);\n\n  function SliderPickerCursor(props) {\n    var _this;\n\n    _classCallCheck(this, SliderPickerCursor);\n\n    _this = _super.call(this, props);\n\n    _this.panResponderGrantHandler = function () {\n      _this.props.slideBeginCallback();\n\n      _this.state.drag.setOffset({\n        x: _this.state.drag.x._value,\n        y: _this.state.drag.y._value\n      });\n\n      _this.state.drag.setValue({\n        x: 0,\n        y: 0\n      });\n    };\n\n    _this.panResponderMoveHandler = function (gesture) {\n      var finalValue = gesture.dx + _this.state.latestPosition;\n\n      if (_this.errorToleranceMargin && (gesture.dy > _this.errorToleranceMargin || gesture.dy < _this.errorToleranceMargin * -1)) {\n        if (!_this.state.xOffsetAtToleranceMarginSurpassed) {\n          _this.setState({\n            xOffsetAtToleranceMarginSurpassed: gesture.dx\n          });\n        }\n\n        return null;\n      }\n\n      if (finalValue >= 0 && finalValue <= _this.maxOffset) {\n        if (_this.state.xOffsetAtToleranceMarginSurpassed) {\n          _this.setState({\n            xOffsetAtToleranceMarginSurpassed: null\n          });\n        }\n\n        _this.state.drag.setValue({\n          x: gesture.dx,\n          y: 0\n        });\n      }\n    };\n\n    _this.getOffsetPosition = function (value) {\n      var nearest = _this.offsetsMap.filter(function (obj) {\n        return obj.value === value;\n      });\n\n      return nearest[0].offset;\n    };\n\n    _this.panResponderReleaseHandler = function (gesture) {\n      var finalValue = gesture.dx + _this.state.latestPosition;\n\n      if (_this.state.xOffsetAtToleranceMarginSurpassed) {\n        finalValue = _this.state.xOffsetAtToleranceMarginSurpassed + _this.state.latestPosition;\n\n        _this.setState({\n          xOffsetAtToleranceMarginSurpassed: null\n        });\n      }\n\n      var newPosition;\n      var updatedOffsetX;\n\n      if (finalValue >= 0 && finalValue <= _this.maxOffset) {\n        var nearestNumber = _this.getNearestHandler(finalValue);\n\n        var nearestOffset = _this.offsetsMap.filter(function (obj) {\n          return obj.value === nearestNumber;\n        });\n\n        nearestOffset = nearestOffset[0].offset;\n        newPosition = nearestOffset;\n\n        if (nearestOffset === _this.state.latestPosition) {\n          updatedOffsetX = 0;\n        } else if (nearestOffset < _this.state.latestPosition) {\n          updatedOffsetX = (_this.state.latestPosition - nearestOffset) * -1;\n        } else {\n          updatedOffsetX = nearestOffset - _this.state.latestPosition;\n        }\n      } else {\n        if (gesture.dx > 0) {\n          newPosition = _this.maxOffset;\n          updatedOffsetX = _this.maxOffset - _this.state.latestPosition;\n        } else {\n          newPosition = 0;\n          updatedOffsetX = _this.state.latestPosition * -1;\n        }\n      }\n\n      _this.releaseCallback(_this.getNearestHandler(finalValue));\n\n      _this.state.drag.setValue({\n        x: updatedOffsetX,\n        y: 0\n      });\n\n      _this.setState({\n        latestPosition: newPosition\n      });\n\n      _this.state.drag.flattenOffset();\n    };\n\n    _this.nonDraggablePressHandler = function (locationX) {\n      var nearestNumber = _this.getNearestHandler(locationX);\n\n      var nearestOffset = _this.offsetsMap.filter(function (obj) {\n        return obj.value === nearestNumber;\n      });\n\n      nearestOffset = nearestOffset[0].offset;\n\n      _this.releaseCallback(nearestNumber);\n\n      _this.state.drag.setValue({\n        x: nearestOffset - _this.buttonWidth * .5,\n        y: 0\n      });\n\n      _this.setState({\n        latestPosition: nearestOffset\n      });\n\n      _this.state.drag.flattenOffset();\n    };\n\n    _this.getNearestHandler = function (value) {\n      if (value >= _this.maxOffset) {\n        return _this.offsetsMap[_this.offsetsMap.length - 1].value;\n      } else if (value <= 0) {\n        return 0;\n      }\n\n      var nearest = _this.offsetsMap.reduce(function (prev, curr) {\n        return Math.abs(curr.offset - value) < Math.abs(prev.offset - value) ? curr : prev;\n      });\n\n      return nearest.value;\n    };\n\n    _this.styleChecker = function (styleObject, key, value) {\n      if (!Object.keys(styleObject).includes(key)) {\n        styleObject[key] = value;\n      }\n    };\n\n    _this.buttonBackgroundColor = _this.props.buttonBackgroundColor ? _this.props.buttonBackgroundColor : 'white';\n    _this.buttonBorderColor = _this.props.buttonBorderColor ? _this.props.buttonBorderColor : 'dimgrey';\n    _this.buttonBorderWidth = _this.props.buttonBorderWidth ? _this.props.buttonBorderWidth : 1;\n    _this.buttonDimensionsPercentage = _this.props.buttonDimensionsPercentage ? _this.props.buttonDimensionsPercentage : 6;\n    _this.defaultValue = _this.props.defaultValue ? _this.props.defaultValue : 5;\n    _this.maxOffset = _this.props.maxOffset ? _this.props.maxOffset : vw(85);\n    _this.maxValue = _this.props.maxValue ? _this.props.maxValue : 10;\n    _this.releaseCallback = _this.props.releaseCallback ? _this.props.releaseCallback : function () {};\n    _this.slideBeginCallback = _this.props.slideBeginCallback ? _this.props.slideBeginCallback : function () {};\n    _this.errorToleranceMargin = _this.props.errorToleranceMargin ? _this.props.errorToleranceMargin : null;\n    _this.buttonStylesOverride = _this.props.buttonStylesOverride ? _this.props.buttonStylesOverride : null;\n    _this.buttonWidth = vw(_this.buttonDimensionsPercentage);\n\n    if (_this.buttonStylesOverride && Object.keys(_this.buttonStylesOverride).includes('width')) {\n      _this.buttonWidth = _this.buttonStylesOverride['width'];\n    }\n\n    if (_this.defaultValue > _this.maxValue) {\n      _this.defaultValue = _this.maxValue;\n    }\n\n    _this.offsetsMap = [];\n\n    for (var i = 0; i <= _this.maxValue; i++) {\n      _this.offsetsMap.push({\n        offset: _this.maxOffset * (i / _this.maxValue),\n        value: i\n      });\n    }\n\n    _this.state = {\n      drag: new Animated.ValueXY(),\n      latestPosition: _this.getOffsetPosition(_this.defaultValue),\n      xOffsetAtToleranceMarginSurpassed: null\n    };\n\n    _this.state.drag.setValue({\n      x: _this.getOffsetPosition(_this.defaultValue) - _this.buttonWidth * .5,\n      y: 0\n    });\n\n    _this._panResponder = PanResponder.create({\n      onStartShouldSetPanResponder: function onStartShouldSetPanResponder() {\n        return true;\n      },\n      onPanResponderGrant: function onPanResponderGrant(evt, gesture) {\n        _this.panResponderGrantHandler();\n      },\n      onPanResponderMove: function onPanResponderMove(evt, gesture) {\n        _this.panResponderMoveHandler(gesture);\n      },\n      onPanResponderRelease: function onPanResponderRelease(evt, gesture) {\n        _this.panResponderReleaseHandler(gesture);\n      },\n      onPanResponderTerminate: function onPanResponderTerminate(evt, gesture) {\n        _this.panResponderReleaseHandler(gesture);\n      }\n    });\n    return _this;\n  }\n\n  _createClass(SliderPickerCursor, [{\n    key: \"render\",\n    value: function render() {\n      var circleStyles = this.buttonStylesOverride ? _extends({}, this.buttonStylesOverride) : {};\n      this.styleChecker(circleStyles, 'backgroundColor', this.buttonBackgroundColor);\n      this.styleChecker(circleStyles, 'borderColor', this.buttonBorderColor);\n      this.styleChecker(circleStyles, 'borderWidth', this.buttonBorderWidth);\n      this.styleChecker(circleStyles, 'height', vw(this.buttonDimensionsPercentage));\n      this.styleChecker(circleStyles, 'width', vw(this.buttonDimensionsPercentage));\n      this.styleChecker(circleStyles, 'borderRadius', vw(this.buttonDimensionsPercentage) * .5);\n      return _jsx(Animated.View, _objectSpread(_objectSpread({}, this._panResponder.panHandlers), {}, {\n        style: [this.state.drag.getLayout(), circleStyles]\n      }));\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate(prevProps) {\n      if (prevProps.triggerNonDraggablePress !== this.props.triggerNonDraggablePress && prevProps.nonDraggablePressLocation !== this.props.nonDraggablePressLocation) {\n        this.nonDraggablePressHandler(this.props.nonDraggablePressLocation);\n      }\n    }\n  }]);\n\n  return SliderPickerCursor;\n}(Component);","map":{"version":3,"names":["React","Component","vh","vw","SliderPickerCursor","props","panResponderGrantHandler","slideBeginCallback","state","drag","setOffset","x","_value","y","setValue","panResponderMoveHandler","gesture","finalValue","dx","latestPosition","errorToleranceMargin","dy","xOffsetAtToleranceMarginSurpassed","setState","maxOffset","getOffsetPosition","value","nearest","offsetsMap","filter","obj","offset","panResponderReleaseHandler","newPosition","updatedOffsetX","nearestNumber","getNearestHandler","nearestOffset","releaseCallback","flattenOffset","nonDraggablePressHandler","locationX","buttonWidth","length","reduce","prev","curr","Math","abs","styleChecker","styleObject","key","Object","keys","includes","buttonBackgroundColor","buttonBorderColor","buttonBorderWidth","buttonDimensionsPercentage","defaultValue","maxValue","buttonStylesOverride","i","push","Animated","ValueXY","_panResponder","PanResponder","create","onStartShouldSetPanResponder","onPanResponderGrant","evt","onPanResponderMove","onPanResponderRelease","onPanResponderTerminate","circleStyles","panHandlers","getLayout","prevProps","triggerNonDraggablePress","nonDraggablePressLocation"],"sources":["/home/joanmarc/Escriptori/coding/soloProject/vaTerra-plant-project/vaTerra/node_modules/react-native-slider-picker/src/components/SliderPickerCursor.js"],"sourcesContent":["/**\n * react-native-slider-picker - NPM Package\n *\n * @module /SliderPickerCursor\n * @description Generic pre-styled slide picker cursor. Animated component that can be dragged within it's parent.\n * @param {String} buttonBackgroundColor - Optional. Sets background color of Slider's button. Can pass valid React Native color keywords, hexidecimal, rgb(), or rgba() values. Defaults to `\"white\"`.\n * @param {String} buttonBorderColor - Optional. Sets border color of Slider's button. Can pass valid React Native color keywords, hexidecimal, rgb(), or rgba() values. Defaults to `\"dimgrey\"`.\n * @param {Number} defaultValue - Optional. Default value the cursor will be placed in <SliderPicker> on.\n * @param {Number} errorToleranceMargin - Optional. Defaults to `50` in `<SliderPicker>`. Margin of error for user to move drag off of the cursor along the Y Axis of the screen/component. If user drags beyond this amont of units in either vertical direction the PanResponder event will not update position of cursor. Is checked to ensure a `Number` type is passed that is greater than `0`.\n * @param {Number} maxOffset - Optional. X-axis coordinates of right-edge of <SliderPicker>. Component cannot be draggeed right past this point.\n * @param {Number} nonDraggablePressLocation - X-axis location of user press within <SliderPicker>. Combined with triggerNonDraggablePress, determines whether or not handler function should be called for user presses within the parent component. \n * @param {Function} releaseCallback - Optional. Called when touch/gesture of component ends either by user releasing their finger, the panResponder event being terminated by the user's touch leaving the component, or when the user presses within the parent component.\n * @param {Function} slideBeginCallback  - Optional. Callback function to be executed when Slider's touch event begins. Called in `onPanResponderGrant` property of the component's `panResponder`. Defaults to `() => {}`.\n * @param {Boolean} triggerNonDraggablePress - Combined with nonDraggablePressLocation, determines whether or not handler function should be called for user presses within the parent component.\n */\n\n//------------------------------------------------------------------------------\n// Imports\n//------------------------------------------------------------------------------\n// Libraries\nimport React, { Component } from \"react\";\nimport { Animated, PanResponder } from \"react-native\";\nimport { vh, vw } from 'react-native-css-vh-vw';\n\n//------------------------------------------------------------------------------\n// Component\n//------------------------------------------------------------------------------\nexport class SliderPickerCursor extends Component {\n  constructor(props) {\n    super(props);\n\n    // Props checking\n    this.buttonBackgroundColor =  this.props.buttonBackgroundColor ? this.props.buttonBackgroundColor : 'white';\n    this.buttonBorderColor =  this.props.buttonBorderColor ? this.props.buttonBorderColor : 'dimgrey';\n    this.buttonBorderWidth = this.props.buttonBorderWidth ? this.props.buttonBorderWidth : 1;\n    this.buttonDimensionsPercentage = this.props.buttonDimensionsPercentage ? this.props.buttonDimensionsPercentage : 6;\n    this.defaultValue = this.props.defaultValue ? this.props.defaultValue : 5;\n    this.maxOffset = this.props.maxOffset ? this.props.maxOffset : vw(85);\n    this.maxValue = this.props.maxValue ?  this.props.maxValue : 10;\n    this.releaseCallback = this.props.releaseCallback ? this.props.releaseCallback : () => {};\n    this.slideBeginCallback = this.props.slideBeginCallback ? this.props.slideBeginCallback : () => {};\n    this.errorToleranceMargin = this.props.errorToleranceMargin ? this.props.errorToleranceMargin : null;\n\n    // Check override style props\n    this.buttonStylesOverride = this.props.buttonStylesOverride ? this.props.buttonStylesOverride : null;\n\n    // Set buttonWidth to width passed for dimensions by default\n    this.buttonWidth = vw(this.buttonDimensionsPercentage);\n\n    // If button styles have been override and the override styles have a width property\n    if ( this.buttonStylesOverride && Object.keys(this.buttonStylesOverride).includes('width') ) {\n      // Set buttonWidth to the value passed in styles override.\n      this.buttonWidth = this.buttonStylesOverride['width'];\n    }\n\n    // Make sure that defaultValue isn't out of range\n    if (this.defaultValue > this.maxValue) {\n      this.defaultValue = this.maxValue;\n    }\n    \n    // Initialize empty array to store xOffsets in\n    this.offsetsMap = [];\n\n    // Get x-axis positioning of each number/separator\n    for (let i = 0; i <= this.maxValue; i++) {\n      this.offsetsMap.push({\n        offset: this.maxOffset * (i / this.maxValue),\n        value: i\n      });\n    }\n\n    // Initialize state\n    this.state = {\n      // Create instance of Animated.XY, which interpolates X and Y values, in our case, we'll only need the X value.\n      drag: new Animated.ValueXY(),\n      // used to reference latestPosition of draggable view. Updated onPanResponderRelease.\n      latestPosition: this.getOffsetPosition(this.defaultValue),\n      // Used to set state on drag if user drags past Y axis threshold.\n      xOffsetAtToleranceMarginSurpassed: null\n    };\n\n    // Initialize value to accomodate for width of button\n    this.state.drag.setValue({ \n      x: this.getOffsetPosition(this.defaultValue) - (this.buttonWidth * .5),\n      y: 0 \n    });\n\n    // Create panResponder, which is responsible for the dragging\n    this._panResponder = PanResponder.create({\n      onStartShouldSetPanResponder : () => true,\n      onPanResponderGrant: (evt, gesture) => {\n        this.panResponderGrantHandler()\n      },\n      onPanResponderMove: (evt, gesture) => { // When user moves cursor/button\n        this.panResponderMoveHandler(gesture);\n      },\n      onPanResponderRelease: (evt, gesture) => { // When user press/drag ends\n        this.panResponderReleaseHandler(gesture)\n      },\n      onPanResponderTerminate: (evt, gesture) => { // When user's touch/gesture is move outside of the button/cursor of <SliderPickerCursor>\n        this.panResponderReleaseHandler(gesture);\n      }\n    });\n  }\n\n  /**\n   * Render\n   */\n  render() {\n\n    //\n    // Set dynamic styles based on props\n    //\n\n    // Initialize circle styles\n    let circleStyles = this.buttonStylesOverride ? Object.assign({}, this.buttonStylesOverride) : {};\n    \n    // Set color and border width\n    this.styleChecker(circleStyles, 'backgroundColor', this.buttonBackgroundColor);\n    this.styleChecker(circleStyles, 'borderColor', this.buttonBorderColor);\n    this.styleChecker(circleStyles, 'borderWidth', this.buttonBorderWidth);\n\n    // Set dimensions and shape\n    this.styleChecker(circleStyles, 'height', vw(this.buttonDimensionsPercentage));\n    this.styleChecker(circleStyles, 'width', vw(this.buttonDimensionsPercentage));\n    this.styleChecker(circleStyles, 'borderRadius', vw(this.buttonDimensionsPercentage) * .5);\n\n    return (\n      <Animated.View \n        {...this._panResponder.panHandlers} // Add _panResponder's handlers to component\n        style={[this.state.drag.getLayout(), circleStyles]} // Include layout from this.state.drag in styles\n      >     \n      </Animated.View>\n    )\n  }\n\n  /** \n   * On componentDidUpdate:\n   * If previous props for triggerNonDraggablePressLocation and nonDraggablePressLocation are not equal to current props (user has pressed the component outside of <SliderPickerCursor> and triggered an event), execute the nonDraggablePressHandler.\n   */\n  componentDidUpdate(prevProps) {\n    // If user triggered a button press and we have x location of event\n    if (prevProps.triggerNonDraggablePress !== this.props.triggerNonDraggablePress &&\n        prevProps.nonDraggablePressLocation !== this.props.nonDraggablePressLocation) {\n      this.nonDraggablePressHandler(this.props.nonDraggablePressLocation);\n    }\n  }\n  \n  /** \n   * Event handler for when panResponder gesture has started. Sets x offset and x/y value of drag panResponder instance.\n   * @return {Function} Executes this.state.drag.setOffset and this.state.drag.setValue.\n   */\n  panResponderGrantHandler = () => {\n    this.props.slideBeginCallback();\n    // Set offset state.drag to prevent Animated.View from returning to 0 coordinates \n    // when it is moved again.\n    this.state.drag.setOffset({x: this.state.drag.x._value, y: this.state.drag.y._value});\n    // Set value to 0/0 to prevent AnimatedView from \"jumping\" on start of drag. Stabilizes the component.\n    this.state.drag.setValue({x: 0, y: 0})\n  }\n\n  /** \n   * Event handler for when panResponder moves. Calculates final x-location of drag instance based on sum of gesture distance moved and the most recent position of the <SliderPickerCursor> component within the <Slider>.\n   * @param {Object} gesture - The gestureState object passed as a param to each panResponder callback.\n   * @return {Function} Executes this.state.drag.setValue to update x value if sum of gesture change and this.state.latestPosition is within the bounds of the <Slider>.\n   */\n  panResponderMoveHandler = (gesture) => {\n    // Get the final value that user has dragged to.\n    let finalValue = gesture.dx + this.state.latestPosition;\n\n    // If user has dragged past the yAxis threshold, cancel event\n    if (this.errorToleranceMargin && \n        (gesture.dy > this.errorToleranceMargin || gesture.dy < (this.errorToleranceMargin * -1) )) {\n      // If there isn't already a value in state for xOffsetAtToleranceMarginSurpassed\n      if (!this.state.xOffsetAtToleranceMarginSurpassed) {\n        // Set value in state\n        this.setState({ xOffsetAtToleranceMarginSurpassed: gesture.dx });\n      }\n      // End function\n      return null;\n    }\n    \n    // If finalValue is in of slider, update state.drag to appropriate position\n    if (finalValue >= 0 && finalValue <= (this.maxOffset) ) {\n      // If there was value set when user dragged out of bounds vertically\n      if (this.state.xOffsetAtToleranceMarginSurpassed) {\n        // Clear that value in state\n        this.setState({ xOffsetAtToleranceMarginSurpassed: null });\n      }\n      this.state.drag.setValue({ x: gesture.dx, y: 0 });\n    }\n  }\n\n  /** \n   * Get offset value for start position based on value of this.defaultValue.\n   * @param {Number} defaultValue - Value of this.defaultValue, number where it should \n   * @return {Number} offset value to be set in constructors set in x key of this.state.drag.setValue()\n   */\n  getOffsetPosition = (value) => {\n    let nearest = this.offsetsMap.filter(obj => {\n      return obj.value === value;\n    });\n\n    return nearest[0].offset;\n  }\n\n  /** \n   * Event handler for when panResponder touch event ends. Calculates final x-location of drag instance based on sum of gesture distance moved and the most recent position of the <SliderPickerCursor> component within the <Slider>. Executes callbacks to update state accordingly.\n   * @param {Object} gesture - The gestureState object passed as a param to each panResponder callback.\n   * @return {Function} Exectues props.releaseCallback(), this.state.drag.setValue(), updates this.state.latestPosition, and this.state.drag.flattenOffset(). \n   */\n  panResponderReleaseHandler = (gesture) => {\n\n    // Get the final value that user has dragged to.\n    let finalValue = gesture.dx + this.state.latestPosition;\n\n    // If touch event ended while user was passed y threshold\n    if (this.state.xOffsetAtToleranceMarginSurpassed) {\n      // Update value to that of state.xOffsetAtYThreshould + state.latestPosition\n      finalValue = this.state.xOffsetAtToleranceMarginSurpassed + this.state.latestPosition;\n      // Clear value for xOffsetAtToleranceMarginSurpassed\n      this.setState({ xOffsetAtToleranceMarginSurpassed: null });\n    }\n\n    // Initialize variabels to be used in business logic and update state.\n    let newPosition;\n    let updatedOffsetX;\n\n    // If in bounds\n    if (finalValue >= 0 && finalValue <= this.maxOffset) {\n      \n      // Get number/index of nearest\n      let nearestNumber = this.getNearestHandler(finalValue);\n      \n      // Get x-positioning of nearest number\n      let nearestOffset = this.offsetsMap.filter(obj => {\n        return obj.value === nearestNumber\n      });\n\n      nearestOffset = nearestOffset[0].offset;\n\n      newPosition = nearestOffset;\n\n      // If user returns to original position prior to this panResponder touch\n      if (nearestOffset === this.state.latestPosition) {\n        updatedOffsetX = 0;\n      }\n      // If moved to the left, subtract \n      else if (nearestOffset < this.state.latestPosition) {\n        updatedOffsetX = (this.state.latestPosition - nearestOffset) * -1\n      }\n      // If moved to the right \n      else {\n        updatedOffsetX = nearestOffset - this.state.latestPosition;\n      }\n    }\n    // If drag is out of bounds\n    else {\n      // If gesture.dx is positive\n      if (gesture.dx > 0) {\n        // Set newPosition to maxOffset\n        newPosition = this.maxOffset;\n        // Set value to update offset x with to maxOffset - latestPosition\n        updatedOffsetX = this.maxOffset - this.state.latestPosition;\n      }\n      // If gesture.dx is the same or negative \n      else {\n        // Set newPosition to 0\n        newPosition = 0;\n        // Set value to update offset x with to negative value of latestPosition\n        updatedOffsetX = this.state.latestPosition * -1;\n      }\n    }\n\n    // Execute props callback to lift state to <Slider>\n    this.releaseCallback(this.getNearestHandler(finalValue));\n\n    // Move component to nearest \n    this.state.drag.setValue({ x: updatedOffsetX, y: 0 });\n\n    // Update latestPosition\n    this.setState({ latestPosition: newPosition });\n\n    // Flatten offset on release to prevent bug on repeated drags\n    this.state.drag.flattenOffset();\n  }\n\n  /** \n   * Handler function when the parent <Slider> component is pressed anywhere outside of the <SliderPickerCursor> component. Get's nearest number and offset of the touch event's x-axis coordinates, moves the button to the appropriate spot in the <Slider>, updates state locally and hoists state up to <Slider> to display purposes.\n   * @param {Number} locationX - The value of nativeEvent.locationX where <Slider> component is pressed.\n   * @return {Function} Exectues props.releaseCallback(), this.state.drag.setValue(), updates this.state.latestPosition, and this.state.drag.flattenOffset(). \n   */\n  nonDraggablePressHandler = (locationX) => {\n    // Get number/index of nearest\n    let nearestNumber = this.getNearestHandler(locationX);\n    \n    // Get x-positioning of nearest number\n    let nearestOffset = this.offsetsMap.filter(obj => {\n      return obj.value === nearestNumber\n    });\n\n    nearestOffset = nearestOffset[0].offset;\n\n    // Execute props callback to lift state to <Slider>\n    this.releaseCallback(nearestNumber);\n\n    // Move component to nearest (accommodate for width of component itself).\n    this.state.drag.setValue({ x: nearestOffset - (this.buttonWidth * .5), y: 0 });\n\n    // Update latestPosition\n    this.setState({ latestPosition: nearestOffset });\n\n    // Flatten offset on release to prevent bug on repeated drags\n    this.state.drag.flattenOffset();\n  }\n\n  /** \n   * Helper function to get the nearest x-offset/number of component. Called on panHandlerRelease\n   * @param {Number} value - The x-coordinates within the Slider component the button is at at time of function call.\n   * @return {Number} Number on scale that button is closest to.\n   */\n  getNearestHandler = (value) => {  \n    // If value is out of bounds, set either to 0 or maxValue\n    if (value >= this.maxOffset) {\n      return this.offsetsMap[this.offsetsMap.length - 1].value;\n    }\n    else if (value <= 0) {\n      return 0;\n    }\n\n    // Get nearest value from array of xOffsets\n    const nearest = this.offsetsMap.reduce((prev, curr) => Math.abs(curr.offset - value) < Math.abs(prev.offset - value) ? curr : prev);\n    \n    return nearest.value;\n  }\n\n  /** \n   * Adds a key/value pair to a style object if it does not already have a value for key passed.\n   * @return {null}\n   */\n  styleChecker = (styleObject, key, value) => {\n    // If current style object doesn't include key passed\n    if ( !Object.keys(styleObject).includes(key) ) {\n      // Update it to value passed\n      styleObject[key] = value;\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module"}